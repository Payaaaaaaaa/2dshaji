好的，我将为你编写一份结构化的 Godot 4.4 项目设计文档，目标是开发一个 2D 非对称联机像素游戏，支持后续的 Web、Android 和 iOS 兼容性。文档将面向 Cursor AI 辅助开发优化，包括模块划分、网络结构、提示工程策略、项目目录建议等。

准备好后我会第一时间通知你。


# Godot 4.4 2D 非对称联机像素游戏 项目设计文档

本设计文档描述了一款以 **Godot Engine 4.4.x** 为开发平台的2D像素风格非对称联机游戏的方案。游戏玩法借鉴《黎明杀机》的机制，采用 **1 名杀手 VS 多名幸存者** 的不对称对抗模式。项目将使用 GDScript 编程，实现完整的玩家状态、物件交互、QTE事件、房间匹配、程序化地图、角色能力和音效系统等功能，并通过 Godot 官方高层 Multiplayer API 完成联网同步（服务器权威模式），初期部署于 Web 平台，后续兼容 Android 和 iOS。文档各部分详细阐述核心设计，结构清晰，便于开发过程中 AI 理解和协助实现。

## 1. 核心玩法机制与游戏循环

* **角色与目标：** 游戏中玩家分为两种角色：一方为**杀手**，另一方为**幸存者**。杀手的目标是**追捕并消灭所有幸存者**，而幸存者则需要**合作完成特定目标并逃脱**。通常一局游戏由 **1 名杀手** 对抗 **4 名幸存者**（可根据设计调整幸存者人数），形成不对称的对抗平衡。

* **幸存者目标：** 幸存者主要任务是在地图中**寻找并修复若干发电机**，以恢复电力并开启逃生出口。经典设计为需要修好 **5 台发电机** 后才能启动出口闸门。修理发电机是一个需要一定时间的交互过程（以进度条表示）。过程中会随机出现 **QTE（Quick Time Event，快速反应事件）** 检测，即“技能检查”环节：幸存者必须在正确时机按下提示按钮，成功则继续修复，失败则进度受阻并触发响亮噪音提示杀手。当所有指定数量的发电机被修复后，地图上的逃生门将通电，幸存者可以去开启出口逃生。

* **杀手目标：** 杀手的任务是在幸存者完成目标前**找到并击倒所有幸存者**。杀手通常移动速度比幸存者稍快，拥有特殊能力可以更容易发现或抓捕幸存者。杀手需要用武器**攻击幸存者两次**才能将其击倒（第一次攻击使幸存者受伤减速，第二次攻击使其倒地无法行动）。倒地的幸存者可以被杀手抓起并带到地图上的**钩子**处挂起（模拟《黎明杀机》的处决钩机制）。被挂上的幸存者会进入倒计时的濒死状态，其他幸存者可以在倒计时结束前前往救援将其解救，否则该幸存者将被处决淘汰。每位幸存者通常有被挂两次的机会（第二次被挂时倒计时更短，结束即被淘汰）。如果杀手成功消灭所有幸存者，则杀手获胜；反之有幸存者成功逃生则幸存者一方获胜。

* **游戏循环：** 游戏开始于一个匹配完成的房间，所有玩家加载程序化生成的地图场景。**准备阶段**，幸存者在地图各处随机分散生成，杀手在固定地点生成并有短暂延迟以给予幸存者准备时间。**对局阶段**，幸存者四处搜索发电机并开始合作修理，同时相互掩护避免被杀手发现；杀手则在地图中巡逻，利用视觉线索和声音提示来发现幸存者的位置。每当幸存者修理发电机触发QTE失败或某幸存者受伤倒地时，都会产生声效或视觉提示（例如发电机爆炸火花、幸存者尖叫）供杀手察觉定位。幸存者在追逐中可以利用地图中的障碍物躲藏或绕开杀手，例如翻越窗户、躲进柜子，或者推倒**障碍板**(木板)来暂时阻挡杀手。若某幸存者被杀手击倒并挂上钩子，其他幸存者面临抉择：营救队友或加紧修理发电机。**压迫阶段**，随着幸存者逐步修好更多发电机，地图上对幸存者有利的资源（板子等）变少，杀手施压增强；幸存者若只剩最后一人存活且未开门，可能出现**终极逃生出口**（类似《黎明杀机》的地道机制，可视设计决定是否包含）。**结束阶段**，当幸存者修满发电机并打开出口或杀手消灭所有幸存者后，对局结束，进入结算界面显示胜负结果和统计数据。整个游戏循环旨在营造紧张刺激的猫鼠追逐体验，让幸存者在恐惧中合作求生，让杀手享受猎捕猎物的过程。

## 2. 网络同步结构与房间系统

* **联网架构：** 项目采用 **Godot 4 高层次 Multiplayer API** 实现同步。将使用**客户端-服务器**架构，其中一名玩家充当主机(Server)，其他为客户端。当存在独立服务器时，所有玩家皆为客户端连接至服务器。**服务器拥有游戏权威**，负责最终判定游戏状态，以防止作弊和不一致。在 Godot 高层API下，这意味着大部分游戏逻辑在服务器执行，客户端主要发送输入请求并等待服务器广播状态更新。

* **连接与Peer设置：** 使用 `ENetMultiplayerPeer` 作为默认联网底层，在PC和移动端通过UDP进行通信。在 Web 平台，由于浏览器环境限制，将使用 `WebSocketMultiplayerPeer` 或 WebRTC 实现P2P 连接。服务器监听预定义端口等待客户端接入；客户端通过输入服务器IP（或房间号）连接。Godot 提供的 `multiplayer` 对象用于管理联网：服务器通过 `create_server(port, max_clients)` 建立房间，客户端通过 `create_client(address, port)` 加入房间。成功连接后，每个 Peer 会被分配一个唯一 ID（服务器ID始终为1）。为实现房间列表或匹配，可考虑建立一个简单的服务端大厅，但初期实现中可由玩家直接通过IP/房间号加入。

* **房间系统：** 游戏包含**大厅/房间**机制，让玩家在对局开始前聚集。主机创建房间后进入**房间界面**等待其他玩家，客户端加入后通知服务器并进入该房间。服务器维护一个玩家列表数据结构，记录当前房间内玩家的ID、昵称、角色选择（杀手/幸存者）等。默认情况下第一位进入房间的玩家为杀手（或由房主选择指定），其余均为幸存者。可以设计“切换角色”选项，但需确保同时最多一名杀手，其余为幸存者。房间界面应显示玩家列表及各自的角色和准备状态。服务器通过高层API的信号如 `peer_connected(id)` 和 `peer_disconnected(id)` 来检测玩家进出，并将更新后的玩家列表广播给所有客户端，确保界面同步。准备机制上，可要求所有幸存者点击“准备”后由房主或服务器发出开始信号。

* **同步方式：** 游戏开始时，服务器加载游戏场景并通过 **场景复制** 将场景和对象广播给客户端。Godot 4 提供 **MultiplayerSpawner** 和 **MultiplayerSynchronizer** 节点辅助同步：服务器端可以通过 MultiplayerSpawner 将如玩家角色、道具等节点实例化到所有客户端。关键的对象属性（例如角色位置、动画状态、发电机修理进度等）可以通过 MultiplayerSynchronizer 配置同步，保证客户端自动更新这些属性。对于离散的游戏事件（如攻击命中、QTE 成功/失败），使用 **RPC 调用远程过程** 通知各端。Godot 4 的 GDScript 支持在函数上使用 `@rpc` 注解并指定模式：例如使用 `@rpc("any_peer", "reliable")` 来标记客户端输入RPC，允许任意客户端调用；使用 `@rpc("authority", "call_remote")` 标记服务器专属RPC，仅由服务器调用远程以广播事件。所有RPC接口的实现需遵循服务器判定：客户端请求某动作时（如幸存者尝试修理发电机），实际效果由服务器端逻辑验证后再通过RPC广播给所有客户端应用。

* **服务器权威逻辑：** 客户端主要发送自身输入和意图，所有状态更新（如移动位置、伤害判定）在服务器计算后下发。例如，当幸存者在客户端按下移动键时，本地角色可以立即移动以降低延迟感，但仍需向服务器发送输入RPC，服务器更新权威位置并定期同步各玩家的位置纠正偏差。对快速移动的对象（角色移动等）可以采用**不可靠UDP**传输获取实时性，而对于关键状态（如倒地、被捕获、完成修理）使用**可靠RPC**确保一致。必要时实现客户端预测与服务器校正机制：客户端本地执行简单物理和移动预测，服务器周期性广播权威状态，若差异过大则校正位置，提高平滑度与公平性。由于是实时多人游戏，需针对网络延迟进行设计，例如攻击命中判定可考虑延迟补偿（服务器根据时间戳判断攻击是否在客户端看到的位置命中）。

* **心跳与超时：** 服务器应定期检查客户端连接状态，利用 Godot 的 `ping_interval` 和 `disconnect_timeout` 设置保证在玩家掉线时移除其对象并广播更新。房间系统在游戏进行时可锁定新玩家加入，对局一旦开始新客户端应被拒绝或进入观战模式（可选）。游戏结束后，服务器可解散房间或重置房间状态以便发起下一局，并允许玩家退出或再次准备。

## 3. 模块与代码结构划分（面向 Cursor 开发）

为了便于协同开发和 AI 辅助代码生成，项目将按功能模块进行结构划分。每个模块对应特定的场景和脚本，使逻辑清晰、职责分明。下面是主要模块和代码结构的设计：

* **全局管理模块：** 使用一个 Autoload 脚本（单例，例如 `Global.gd` 或 `GameManager.gd`）承担全局管理职责。该模块初始化网络（创建服务器/客户端Peer并设置 `multiplayer`）、维护当前游戏状态（菜单、房间、对局）、以及在场景切换时保持数据持续。通过 Autoload，全局脚本可在各场景中访问，用于存储如玩家配置、房间信息、全局常量等。`GameManager` 还负责监听网络信号，在收到开始游戏RPC时切换到游戏场景，在游戏结束时切换到结算/大厅场景。

* **网络与房间模块：** 独立脚本 `NetworkManager.gd`（或包含在Global中）封装联网相关逻辑，包括创建/加入房间函数、同步玩家列表、分配角色以及开始游戏的控制。此模块响应 Godot MultiplayerAPI 信号，将玩家连接情况和准备状态通过信号或回调通知UI模块更新显示。房间内的聊天功能（若需要）也可在此模块处理（通过RPC广播聊天消息）。

* **玩家角色模块：** 定义玩家的角色场景和脚本，包括幸存者和杀手两类。考虑使用继承以重用共通功能：

  * 一个基类脚本 `Character.gd`（挂在通用角色场景Character.tscn上），实现移动、基础属性和状态管理逻辑。提供如 `move(direction)` 方法响应输入、`take_damage()` 方法处理被攻击、状态机管理（状态枚举、状态切换函数）等。该基类包含角色公共节点，如Sprite动画节点、碰撞体、状态标识等。
  * 幸存者和杀手分别继承 Character 脚本：`Survivor.gd` 扩展实现幸存者特有行为（修理、被治疗、逃生等），`Killer.gd` 实现杀手特有行为（攻击、抓取、生物能力等）。两者可以是预先继承Character场景并各自保存为 `Survivor.tscn` 和 `Killer.tscn`。在网络同步上，角色场景内可添加 MultiplayerSynchronizer 节点同步关键属性（如位置、朝向、当前状态等）并根据角色由服务器或客户端控制权限。

* **游戏场景与环境模块：** 游戏主要场景 `Game.tscn` 管理地图和环境，包括地形、道具和玩家生成等。该场景的根节点（例如 Node2D）下设子节点：

  * `Environment` 节点：包含TileMap（地形瓦片）、静态障碍物、装饰元素等子节点。
  * `Objects` 节点：作为容器节点，动态实例化游戏交互物件，如发电机、钩子、板子、出口门等。每类物件对应预制场景和脚本（见下）。
  * `Players` 节点：容器节点，用于实例化所有玩家角色（多个幸存者和一名杀手），便于统一管理。如服务器通过 MultiplayerSpawner 将角色场景实例添加到此节点并同步到客户端。
  * `GameLogic` 节点（或由GameManager替代）：处理对局规则，比如监听发电机完成数、判定胜利条件等，可由服务器端运行脚本控制。
  * `HUD` 节点：CanvasLayer或 Control，用于呈现游戏内UI（见第6节）。

* **物件与交互模块：** 各种可交互对象设计为独立场景+脚本：

  * 发电机 (`Generator.tscn` + `Generator.gd`)：包含动画（损坏火花等）、进度属性和交互逻辑。幸存者可以对其执行“修理”交互，脚本维护修理进度、定时触发QTE检查事件（服务器端随机产生事件，通过RPC通知特定幸存者客户端显示QTE UI），并在完成修理时触发完成信号。Generator.gd 脚本需含有如 `start_repair(player)`, `stop_repair(player)` 等方法和一个 `progress` 属性，由 MultiplayerSynchronizer 同步给所有客户端更新进度显示。
  * 出口门 (`ExitGate.tscn` + `ExitGate.gd`)：初始为关闭状态，属性如 `isPowered`（是否通电）。当发电机全部完成时，由GameLogic将 ExitGate 的 `isPowered` 设为 true 并同步，幸存者可以开始开启门的交互（类似修理进度条过程但无QTE）。ExitGate 脚本监听开启进度，进度完成则宣布游戏可结束（幸存者逃脱成功）。
  * 钩子 (`Hook.tscn` + `Hook.gd`)：分布地图，用于挂起幸存者。Killer靠近倒地幸存者按下交互键，即调用幸存者节点的 `get_carried(killer)` 方法将其状态设为“被扛起”，随后若杀手在附近 Hook 处按下交互，调用 Hook 脚本的 `hook_survivor(survivor)` 将幸存者挂上。Hook 脚本负责开始幸存者倒计时（模拟挣扎阶段），倒计时结束通过GameLogic判定幸存者死亡。幸存者玩家在被挂期间可以通过QTE尝试自救（几率很低）或等待队友救援：队友靠近Hook按交互触发 `unhook_survivor()` RPC，由服务器处理让幸存者恢复到受伤状态重新游戏。
  * 障碍板 (`Pallet.tscn` + `Pallet.gd`)：地图预置的木板障碍，幸存者可交互推倒。推倒后在一定时间内形成阻挡物，并对正巧经过的杀手造成短暂眩晕（状态机进入“受挫”状态若实现）。Pallet 状态（竖立/倒下）应同步给所有客户端，推倒动作由服务器RPC广播。
  * 其他物件：如**柜子/储物箱**（可躲藏或获取道具），**道具**（医疗箱、工具箱等）可视开发阶段决定简化或扩展。这些物件均可按以上模式设计独立脚本并在Game场景生成。

* **UI模块：** UI界面按场景分为：主菜单UI (`MainMenu.tscn` + 脚本)、房间大厅UI (`Lobby.tscn` + 脚本)、游戏HUD UI (`HUD.tscn` + 脚本) 等。各UI脚本通过信号与全局/网络模块通信，例如 Lobby UI 脚本将“开始游戏”按钮连接到 NetworkManager 的函数，HUD UI 通过监听GameLogic的信号更新倒计时或目标数量。UI模块的脚本命名如 `MainMenu.gd` 等，并在**Cursor**编辑器中按需拆分功能，以利于AI逐个生成。例如将HUD划分为子控件脚本（如发电机进度组件、QTE提示组件）便于独立开发。

**模块划分概览：**

| 模块/脚本                    | 功能描述                                |
| ------------------------ | ----------------------------------- |
| **Global.gd** (autoload) | 全局游戏管理：维护网络连接、游戏阶段状态切换、全局数据。        |
| **NetworkManager.gd**    | 联网和房间逻辑：创建/加入房间，管理玩家列表，广播房间状态。      |
| **Character.gd**         | 角色基类：移动控制、通用属性（速度、状态）、受伤/倒地处理。      |
| **Survivor.gd**          | 幸存者逻辑：修理互动、被治疗/救援、逃生，实现幸存者状态机。      |
| **Killer.gd**            | 杀手逻辑：攻击与命中判定、抓取携带、特殊能力，实现杀手状态机。     |
| **Generator.gd**         | 发电机：修理进度、QTE触发、完成和爆炸事件（声音通知杀手）。     |
| **ExitGate.gd**          | 出口门：通电及开启进度，逃生判定。                   |
| **Hook.gd**              | 钩子：幸存者挂起与挣扎计时、救援处理。                 |
| **Pallet.gd** (可选)       | 木板：放倒交互，阻挡与杀手眩晕判定。                  |
| **GameLogic.gd**         | 对局逻辑：跟踪发电机完成数、幸存者存活数，判定胜利条件并触发结算。   |
| **MainMenu.gd**          | 主菜单界面逻辑：开始游戏/加入房间按钮，设置选项。           |
| **Lobby.gd**             | 房间界面逻辑：显示玩家列表、角色、准备状态，“开始”按钮控制。     |
| **HUD.gd**               | 游戏内HUD：显示任务进度（发电机数）、玩家状态、计时和QTE提示等。 |
| **AudioManager.gd** (可选) | 音频管理：根据事件播放对应音效（可也由各对象脚本直接处理音频）。    |

以上模块各自职责单一，相互通过**信号**和**全局单例**通信，形成松耦合结构。在 Cursor 编辑器中，可根据设计文档逐一实现各模块。建议首先实现基础模块（网络、角色基类、场景切换），再分别实现幸存者/杀手逻辑，最后完善交互物件和UI，逐步集成测试。模块划分清晰有助于AI理解上下文，在编写某一模块代码时可引用相关模块接口契约（例如函数名、信号名）确保集成无误。

## 4. 地图与场景结构设计（含程序化生成功能）

* **地图布局：** 游戏地图为 **2D 平面**（俯视角或斜45度视角皆可，取决于美术风格），包含室外和障碍布局以提供追逐环境。地图需足够大以供隐蔽和追逐，但也不能过大以免幸存者轻易躲藏。可以借鉴《黎明杀机》的地图结构：有**主要目标区域**（散布着发电机）、**多条路径**（板区、窗户、地形高低差如果有）和**若干狭窄瓶颈**来制造遭遇。由于是像素2D，美术上可采用TileMap拼接地形或手绘整图加碰撞。地图边界可以是围墙或树林等障碍，防止玩家走出范围。

* **场景层次结构：** 地图场景可以通过组合多个子场景构成，便于程序化生成和复用：

  * **地形底板：** 使用 TileMap 节点铺设地面和墙体。设计多张地形tile（草地、道路、建筑地板等）随机排列以增加变化。碰撞形状可直接附加在TileMap或使用静态碰撞对象描绘不可通过的区域（如建筑墙壁、石头）。
  * **固定地标：** 放置少量显著地标（如废弃房屋、谷仓、迷宫墙等）形成地图结构骨架。这些可预先设计成若干模板场景，每次开局随机选择组合摆放，确保地图整体框架在可控范围内变化。
  * **交互物件：** 在地图上随机分布关键对象的位置，如发电机、钩子、板子和出口门等。**程序化生成**时，可使用预设的若干可能坐标或区域，从中随机挑选不重复的位置放置对象。例如设定发电机应生成在若干指定区域内，每局随机选择其中5个点放置发电机Prefab，钩子则在地图各处平均分布一定数量（比如8个）等。需确保无论生成如何，地图都至少有一条从幸存者出生点通往各发电机和出口的路径，避免出现无法达到的死区。

* **随机种子与一致性：** 程序化地图生成必须在所有玩家间保持一致。推荐做法是**仅在服务器**执行地图生成逻辑，然后将结果同步到客户端。实现方式：服务器在开始游戏时确定一个随机种子（如 `randi()` 或时间戳），使用该种子决定地图布局（选择哪套地标模板、各物件生成的位置等）。随后服务器实例化地图场景和各物件，通过 MultiplayerSpawner 将这些节点分发到客户端，以确保每个客户端生成完全相同的地图布局。这样可以避免浮点差异和乱序导致的不一致。如果出于带宽考虑，也可以仅将随机种子广播给客户端，在每个客户端本地以相同算法生成地图，但必须非常谨慎验证完全确定性，通常直接由服务器生成并广播更简单可靠。

* **地图多样性：** 为增加可玩性，可设计多套地图主题与配置。例如不同环境（森林、医院、工厂等）对应不同TileSet和装饰资源。每套环境中再通过程序化改变细节，从而每局地图都有所不同。可以创建一个关卡配置资源，包含某主题下可用的tile集合、可用障碍物Prefab列表、生成规则参数（如发电机生成的数量、板子数量范围等），由服务器在开局随机选择一个配置来生成地图。这样未来可以扩展更多关卡，只需增加配置和资源，无需修改核心逻辑。

* **路径与导航：** 由于杀手与幸存者都由真人操控，本项目不需要复杂的AI寻路。但在设计地图时要考虑**可导航性**：确保场景中走道宽度合理（至少容纳1-2人通过），同时提供一定数量的封闭空间和绕行路线供幸存者甩开杀手。若以后添加AI机器人，则可考虑在地图中添加 NavigationPolygon 或 NavigationMesh 以供 NavigationAgent2D 使用自动寻路。

* **性能与优化：** 地图可能包含大量tile和对象。需注意Godot在Web和移动平台上的性能：TileMap应尽量合并tile贴图集以减少绘制调用；装饰物尽可能做成静态合批的元素。可以在地图较大时，将场景划分为多个区块，根据玩家位置加载/卸载以节省性能（流地图）。不过作为初期版本，地图规模可控制在单屏加载下合理范围。像素风格下贴图尺寸较小，也利于降低内存占用。

* **场景示例：** 下面示例一个可能的场景节点结构：

  ```
  GameScene (Node2D)
  ├── Environment (Node2D)
  │   ├── TileMap (地形拼贴，包含地面和墙体碰撞)
  │   └── Landmark1/2/... (StaticBody2D 或 Node2D，预置的建筑/障碍)
  ├── Objects (Node2D)
  │   ├── Generators (Node2D) 
  │   │    ├── Generator@1 (Generator 场景实例)
  │   │    ├── Generator@2 
  │   │    └── ... (总共例如5台发电机)
  │   ├── Hooks (Node2D)
  │   │    ├── Hook@1
  │   │    └── ... (若干钩子)
  │   ├── Pallets (Node2D)
  │   │    ├── Pallet@1
  │   │    └── ... (若干板子)
  │   └── ExitGate (ExitGate 场景实例)
  ├── Players (Node2D)
  │   ├── Killer (杀手角色实例)
  │   ├── Survivor@1 
  │   ├── Survivor@2 
  │   └── ... (幸存者实例，根据实际玩家数)
  ├── GameLogic (Node)  - 负责游戏规则判定的脚本节点
  └── HUD (CanvasLayer)
      ├── SurvivorHUD (Control, 针对幸存者UI子节点)
      └── KillerHUD   (Control, 针对杀手UI子节点)
  ```

  如上，按功能归类节点，便于在代码中批量管理（例如通过 `Players.get_children()` 获取所有角色进行更新）。场景中各种对象节点可以提前放置若干占位容器，然后由服务器实例填充。这样结构清晰，各模块分工明确。

## 5. 玩家与物件数据结构（状态机、动画、交互）

**玩家角色数据结构：** 玩家分为幸存者和杀手，两类角色都需要维护自身状态及行为。使用 **有限状态机 (FSM)** 模型来管理角色状态有助于避免复杂的条件判断。可在 `Character.gd` 基类中定义一个 `state` 枚举或字符串，以表示当前状态，并提供 `change_state(new_state)` 方法集中处理进入/退出状态的逻辑（如播放动画、初始化计时）。下面分别列出幸存者和杀手的主要状态及属性设计：

* **幸存者状态机：**

  * **Idle（待命）：** 默认状态，未进行特殊动作时的空闲/移动状态。此状态下角色可自由移动、转向和观察。动画表现为待机或行走循环（依据移动输入自动切换）。如果角色未受伤则移动速度正常，若处于受伤状态则在Idle移动时速度降低并伴随跛行动画。

  * **Repairing（修理中）：** 幸存者在发电机附近按下交互键进入“修理”状态。角色停止移动，播放修理动作动画（如蹲下摆弄发电机的帧动画）。此状态由发电机对象管理进度，持续若干秒直至发电机修好或幸存者中断。期间会定时收到来自服务器的QTE事件通知：在本地弹出QTE UI，等待玩家及时按键。若玩家成功，继续保持修理状态；若失败，则通过网络通知服务器触发发电机“爆炸”效果（进度倒退并发出噪音）且幸存者短暂硬直退出修理状态。成功完成修理则触发状态退出，角色可重新移动。修理状态中若遭到攻击，则会立刻中断并切换到受伤或倒地状态。

  * **Helping（救援/治疗）：** 幸存者对队友进行救援或治疗时进入此状态。比如在钩子旁按交互解救队友，或使用医疗包为受伤队友疗伤。角色执行对应动作动画，过程可能需要持续数秒，可以类似修理那样有进度条和可能的QTE（治疗时也可加QTE检查）。完成后状态结束。过程中若中断（玩家松键或被攻击）则取消。

  * **Running（奔跑）：** 虽然奔跑可看作Idle子状态（通过输入触发动画改变），但在玩法上幸存者**跑动**会留下痕迹（例如《黎明杀机》中奔跑产生的红色划痕）供杀手短暂可见。这可在状态机中用一个布尔变量标识是否奔跑。按住“加速”键进入奔跑状态，提高移动速度但增加自身被发现风险。松开则回到普通Idle移动。

  * **Injured（受伤）：** 幸存者被杀手攻击命中一次后进入“受伤”状态（若再次受伤则倒地）。受伤状态不是互斥的行动状态，而是一个**状态标志**，通常幸存者受伤后仍可移动（Idle/Run子状态）但速度降低，并会定时发出呻吟声（声音提示）。此时角色Sprite应切换为受伤姿态（扶着自己、流血效果）。受伤状态可以通过队友治疗来移除，恢复到健康状态。

  * **Downed（倒地）：** 幸存者第二次被击中或从受伤状态再受一次伤害，将倒地爬行。倒地状态下角色只能缓慢爬动且无法进行其他互动。倒地后杀手可上前执行“拾起”交互。若杀手暂未拾起，幸存者可以缓慢爬行一段时间，甚至尝试自行恢复（如果设计技能允许，如《黎明杀机》中的回复技能）。倒地状态显示特殊动画（趴在地上匍匐）。

  * **Carried（被扛起）：** 当杀手拾起倒地幸存者时，幸存者进入“被扛”状态。此时由杀手移动决定幸存者位置，幸存者自身无法控制移动，但可以尝试挣扎。可设计一个挣扎进度或QTE，若幸存者在被扛一段时间内多次完成挣扎QTE且杀手未及时挂钩，则幸存者可提前逃脱落地（回到倒地状态）。否则该状态一直持续，直到被挂上钩子或挣扎成功逃脱。被扛状态以幸存者在杀手肩上动画表现。

  * **Hooked（被挂）：** 幸存者被挂在钩子上后进入“挂钩”状态。角色悬挂不动，不能移动，仅能进行有限的挣扎互动（QTE快速按键以延缓死亡进度或小概率自救）。挂钩状态分阶段：第一次被挂时有较长倒计时，在计时内若无人救援则进入“挣扎阶段”（第二阶段，倒计时加快且需要不断按键维持生命）；第二次被挂若之前已挣扎过，则倒计时极短，无人救即很快死亡。此状态只能被队友解除（救下）或倒计时结束角色死亡（进入死亡状态）。

  * **Escaping（逃脱中）：** 当出口门打开后，幸存者可冲向出口区域。一旦幸存者进入出口触发区域并确认逃脱，即进入逃脱状态。角色不再受游戏内事件影响，计入已逃生（通常会从地图上消失或者获得无敌加速跑出）。逃脱状态可视为游戏结束的一个结果，不需要复杂逻辑，只需通知服务器该幸存者已逃。

  * **Dead（死亡）：** 幸存者被杀手处决（第二次挂钩倒计时结束）或其他条件死亡（比如流血过多死亡）进入死亡状态。角色对象可能被销毁或标记为死亡状态不再参与游戏。可播放死亡动画或效果。死亡后玩家可以进入观察模式观看队友或等待结算。

* **杀手状态机：**

  * **Idle/Patrol（巡逻）：** 杀手默认状态，四处搜索幸存者。此状态下可以自由移动和查看环境。通常杀手没有“奔跑”区分状态，其移动速度固定稍快于健康幸存者的跑动，以确保追逐时逐渐拉近距离。Idle状态动画为常规移动（可能是小跑步态）。杀手在Idle时持续监听感知：包括视觉直线范围（幸存者直接出现在视野内）以及音效提示（如幸存者奔跑痕迹声、受伤呻吟、发电机爆炸声）。当发现线索时，进入\*\*Chase（追逐）\*\*子状态。

  * **Chase（追逐）：** 当杀手锁定一个目标幸存者开始追击时，可以认为进入追逐状态。这其实不需要一个独立状态来限制动作，但可以用于改变音乐/音效（如播放追逐音乐）、界面提示（如给幸存者心跳加速提示）。在追逐状态杀手的移动和攻击频率可能有所调整（或者简单地仅用于标记当前追逐目标）。实现上，可以用一个布尔变量 `is_chasing` 标记，在UI上显示“血腥冲刺”效果。当追丢目标后可重置该状态。

  * **Attack (攻击)：** 杀手在按下攻击键时进入攻击动作状态。表现为一次前方挥砍动画（期间短暂锁定位置或减速）。攻击分为**准备**、**出手**、**恢复**几个阶段，在这一两秒内杀手不能进行其他动作。需要在攻击判定范围（通常是杀手前方扇形区域）检测碰撞，如果在出手瞬间内有幸存者碰撞体在范围内且未倒地，则判定命中触发对幸存者的伤害RPC。无论是否命中，攻击动作都会进入短暂冷却。在状态机上，Attack可以算瞬时状态，攻击动作结束后即回到Idle或Chase状态。

  * **Carrying（携带）：** 杀手成功击倒并拾起幸存者后进入携带状态。此时杀手移动速度会降低（因为扛着人），不能发动攻击，但可以移动将幸存者带往钩子。屏幕上可以提示距最近钩子的距离或方向（以帮助杀手快速找到挂钩点）。如果幸存者挣扎成功提前逃脱，则状态结束切回追逐（目标再次倒地在附近）。如果杀手在携带状态下到达一钩子范围并按交互，则挂钩成功，进入挂钩事件处理，同时杀手状态恢复Idle。

  * **Stunned（受挫）：** 杀手可能在某些情况下被眩晕或短暂失去行动能力，例如幸存者推倒板子砸中杀手，或者特定道具（闪光弹）致盲杀手。此时杀手进入受挫状态，持续若干秒不能移动或攻击，播放被晕眩的动画。状态结束后自动回到巡逻状态。这个状态在初版中可选实现，用于丰富对抗机制。

  * **Power Ability（能力）：** 若设计特定杀手的特殊能力（如瞬间冲刺、传送、陷阱放置等），可以在状态机中表示当杀手激活能力时进入对应状态。例如“SettingTrap”状态下不能移动但在地上放置陷阱，或“Invisible”状态表示隐身一段时间等。这取决于具体角色设计。为了简化，可在初期先实现一个通用杀手，无特殊技能。设计预留接口，以后可基于此扩展多种杀手能力和状态。

  * **Victory/Dramatic Moments：** 当杀手达成胜利条件（例如所有幸存者死亡或逃跑者达到0人）时，可进入一个Victory状态，在结算前播放特定动作或音效（比如庆祝动作）。同样，若最后一名幸存者逃脱，也可触发特殊反馈（虽然对杀手来说就是游戏结束，没有特殊状态）。

* **角色属性与数据：** 每个角色实例将包含若干属性字段来支撑上述状态逻辑。例如：

  * 通用属性：`health_state`（健康/受伤/倒地），`is_carrying`（杀手是否正扛人），`is_carried`（幸存者是否被扛），`speed_walk` 和 `speed_run`，`attack_cooldown`，`wiggle_progress`（幸存者挣扎进度）等。
  * 计时器/冷却：可以在角色脚本中使用 `Timer` 节点或帧更新 `_process(delta)` 来降低冷却计时，如杀手攻击冷却计时、晕眩持续时间计时等。也可用Coroutines（yield）或DeferredCall处理定时。
  * 网络属性同步：生命状态、位置、朝向、当前动画状态等应同步给所有客户端。Godot 4 可通过 MultiplayerSynchronizer或手动RPC同步。例如角色的`global_position`可由服务器统一广播（或直接通过同步节点自动更新），`health_state`变化也通过RPC通知各端更新HUD显示。

* **角色动画设计：** 采用像素风格帧动画展示角色各种状态。Godot 4 中可使用 `AnimatedSprite2D` 节点搭配 `SpriteFrames` 资源管理帧动画：

  * 幸存者需要的动画：待机、行走/跑动（可用同一组帧不同速率播放或两套动画）、受伤行走（和正常行走帧类似但带伤）、修理发电机（固定姿势动画）、被攻击受击（被击中时的痛苦动画）、倒地爬行、被扛举挣扎、挂钩挣扎、死亡等。每种动画可为8方向、4方向或仅正面/背面，根据美术资源情况决定。如果资源有限，可采用顶视角简化动画方向处理。
  * 杀手需要的动画：巡逻行走、攻击挥动（可能分举刀、挥砍等帧序列）、受挫（眩晕）、扛人行走（肩扛姿势移动）等。杀手通常朝向不频繁改变，可以限制为面朝某一方向追逐以减少动画量，或使用8方向动画增强表现。
  * 动画命名：为了代码控制方便，约定动画名称与状态或动作对应。例如 `"idle"`, `"run"`, `"attack"`, `"repair"`, `"injured_walk"`, `"crawl"`, `"carry_walk"`, `"stunned"` 等。这些名称可在代码中直接调用 `AnimatedSprite2D.play("attack")` 切换。使用统一命名规范可以让AI在根据状态机自动播放动画时更简单可靠。

* **物件交互结构：** 玩家与物件的交互通过 **碰撞检测** 或 **触发区域** 和 **输入事件** 相结合实现：

  * 每个可交互物件（发电机、钩子、板子、出口门等）附带一个 `Area2D` 或 `CollisionShape2D` 用于感知玩家接近。玩家角色也可以有一个`Area2D`（或利用其碰撞体）用于检测周围的交互提示。当幸存者进入某物件范围时，物件可以发出信号（例如 `area_entered(body)`）通知玩家脚本。玩家脚本据此在HUD上显示交互提示（例如“按 F 键 修理”）。
  * 当玩家按下交互键（如“F”或手柄X键），代码会检查当前是否有对应的交互对象。例如在幸存者脚本中维护一个 `interactable_in_range` 变量，当进入物件范围时赋值，离开时清空。按键时如果该变量存在，调用对应物件的交互函数。也可以采用信号连接：进入Area时直接将物件节点连接到玩家的“交互”输入信号上。
  * 交互执行由**服务器验证**：幸存者发送修理请求RPC到服务器，服务器检查该玩家确实在发电机附近且条件满足，然后在服务器端调用发电机的 `start_repair(player_id)` 方法并广播。类似地，杀手挂钩也由服务器判断幸存者确实被扛且在钩子范围。
  * **进度类交互：** 发电机修理、开门、治疗这类需要持续的操作，可以在物件脚本中设置一个进行中的标志和进度值，每帧递增进度或使用Timer计时。玩家保持交互键不放则持续，否则中断。可以在客户端本地也做同步反馈（比如进度条增长），但最终进度以服务器计算为准。完成时服务器广播完成事件（如Generator发送修复完成信号，GameLogic收到后增计数）。
  * **QTE事件：** Quick Time Event在机制上由服务端在特定时刻触发。例如Generator每修理一段时间服务器随机决定触发一次QTE，选择一个参与修理的玩家，通过RPC发送指令到该客户端：“出现QTE”。客户端收到后在HUD上显示QTE小游戏（具体见UI部分），并等待玩家输入。玩家是否按对可以直接在客户端判断立即反馈服务器（减少延迟）：例如客户端本地判断QTE成功或失败，通过 `rpc_id(1, "report_qte_result", generator_id, success)` 发给服务器（ID 1代表服务器）。服务器收到结果再据此处理后果（成功则继续，无事；失败则调用 Generator 的爆炸函数导致声响和进度回退）。由于QTE拼接在持续交互中，不宜完全服务器判断，否则延迟可能使玩家感觉按键不同步，因此可允许客户端在小范围内自行判定，但要防作弊可在服务器也简单验证（比如要求收到结果的时间在触发后某个阈值内属有效，否则判定失败）。
  * **攻击判定：** 杀手攻击通过其攻击碰撞体（可在攻击动画关键帧时启用一个 Area2D 检测前方扇形范围）检测是否碰到幸存者的碰撞体。如果有，在服务器上执行命中逻辑：调用该幸存者的 `take_damage(killer)` 函数。此函数改变幸存者状态（健康→受伤 or 受伤→倒地）并通过RPC通知该幸存者客户端播放受伤动画和声音，也通知所有客户端更新其状态（例如HUD血量图标变化）。需要注意确保同一攻击不会多次判定，可在攻击触发后短时间内禁用碰撞检测或标记已处理。

* **数据结构示例：** 以GDScript定义主要数据，可以在脚本开头用 `enum` 定义状态，或用字典/类来管理。例如：

  ```gdscript
  enum HealthState { HEALTHY, INJURED, DOWNED }
  enum SurvivorState { IDLE, REPAIRING, HELPING, RUNNING, CRAWLING, CARRIED, HOOKED }
  enum KillerState { PATROLLING, CHASING, ATTACKING, CARRYING, STUNNED }
  ```

  并在角色对象中有属性如：

  ```gdscript
  var health_state : HealthState = HealthState.HEALTHY
  var survivor_state : SurvivorState = SurvivorState.IDLE
  var killer_state : KillerState = KillerState.PATROLLING
  ```

  通过状态变量驱动动画播放和逻辑。在 `_physics_process` 或信号回调中根据状态作出行为，例如：

  ```gdscript
  if survivor_state == SurvivorState.REPAIRING:
      # 累积修理进度等
  ```

  物件如发电机可以有：

  ```gdscript
  var progress := 0.0
  var is_being_repaired := false
  const RepairTime = 80.0  # 修满需要的总时间
  ```

  并在每帧或定时更新progress。当progress>=RepairTime时发出完成信号等。

* **整体协作：** 玩家与物件通过上述状态和属性互动，比如幸存者靠近发电机按键→进入Repairing状态、触发发电机progress递增；杀手攻击→改变幸存者health\_state和状态；幸存者倒地→杀手改变target状态并执行拾起等。这些状态变化全部通过**统一的状态机逻辑**管理，确保各边界条件（如正在修理时被攻击）都能正确切换状态，不会卡在非法状态组合。同时，由于多玩家同步，要注意状态变更时由服务器统一仲裁，例如两个幸存者同时尝试救同一个队友，只允许一个成功导致状态改变。设计上预想到各种交互情形并处理冲突，是保证多人游戏稳定性的关键。

## 6. UI 设计方案（主菜单、房间界面、HUD、QTE等）

用户界面采取简洁直观的设计，涵盖从游戏启动到对局结算的各个阶段。采用 Godot 的 UI 控件系统（Control 节点）构建界面，使用容器确保不同分辨率下布局自适应。各界面及其元素如下：

* **主菜单 (Main Menu)：** 游戏的启动界面，提供基本选项：

  * **游戏标题和背景：** 屏幕中央显示游戏名称（暂定）和像素风格背景插画，营造悬疑氛围。背景音乐（若有）在此播放循环。
  * **模式选项：** “创建房间（作为杀手）”、“加入游戏（作为幸存者）” 等按钮。考虑到游戏为1杀手 vs 多幸存者，主菜单可以让玩家直接选择扮演角色并进入相应流程：选择杀手则创建新房间等待幸存者加入，选择幸存者则提示输入房间号/IP以加入现有游戏。如果未来实现匹配服务，可增加“快速开始”按钮自动匹配。
  * **设置 (Settings)：** 打开设置子菜单，调整音量（音乐/音效）、图像质量（像素游戏通常无需复杂设置，但可有全屏/窗口等选项）、控制键位等。
  * **退出 (Quit)：** 在PC端退出游戏；在Web平台可隐藏该按钮。
  * 主菜单UI布局采用中心VBoxContainer排列按钮，或自定义位置。按钮按键映射支持键盘和手柄选择。选项文字使用清晰的大字号字体。

* **房间界面 (Lobby)：** 当玩家创建或加入房间后进入的等待界面：

  * **房间信息：** 界面顶端显示房间ID或名称，当前玩家人数（例如“玩家：3/5”，若上限含杀手则总数=1杀手+4幸存者=5）。
  * **玩家列表：** 中央列出所有已加入玩家的昵称（或ID）和角色。以列表形式显示，每行标明「玩家名 - 角色 - 准备状态」。房主或系统会将第一个玩家标记为杀手，其余为幸存者。如果允许切换角色，可在幸存者名旁给房主提供切换按钮（一般不允许任意切换以免多个杀手）。头像或小图标可以表示身份，例如红色刀锋图标表示杀手，绿色人形表示幸存者。
  * **准备/开始按钮：** 幸存者玩家点击“准备”按钮准备就绪，状态更新在列表中（例如在其名字旁显示一个对勾“✔已准备”）。杀手（房主）有“开始游戏”按钮，但需在所有幸存者都准备后才能点击。一旦点击开始，向服务器发送信号，所有客户端切换加载游戏场景。\*\*注意：\*\*房主也可以是幸存者的情况（如果主菜单支持选择），那么需要逻辑确定谁是杀手（比如第一个进入的幸存者在没有杀手时可以转为杀手或者等待一个人加入作为杀手）。为简化设计，默认房主扮演杀手，这样流程明确。
  * **聊天窗口（可选）：** 房间界面可包含一个小聊天区域供玩家交流战术或聊天（UI为多行文本框 + 输入框）。由于匹配双方是对立关系，通常杀手和幸存者在游戏开始前不应透漏过多信息，但作为房间内社交功能可简易实现。聊天消息通过服务器广播所有。
  * **返回/退出：** 界面底部提供“退出房间”按钮，允许玩家离开回到主菜单。如果房主退出，房间解散并通知其他玩家（可以弹出提示并退回主菜单或指定某幸存者接替为新房主/杀手，根据设计取舍）。

* **游戏内HUD：** 分别为幸存者和杀手提供关键信息显示：

  * **幸存者HUD：**

    * **目标进度：** 屏幕顶端或侧边显示幸存者集体目标进度，如“发电机修复：3/5”。每修好一台发电机服务器广播当前完成数量，HUD同步更新。可以用图标形式表示5个发电机，已完成的以亮色/打勾标记。
    * **队友状态：** 显示所有幸存者的状态列表，一般放在屏幕左下或左侧。每个幸存者对应一个昵称或角色头像，以及状态指示：健康（绿色）、受伤（黄色或红色滴血图标）、倒地（倒下人形图标）、被挂（挂钩图标）或死亡（灰色X）。这些状态由服务器同步，在队友受击、倒地、上钩、死亡时更新。这样玩家可实时了解队友情况。若幸存者有道具（如医疗包）或特殊能力，也可在其状态栏上显示小图标。
    * **技能提示：** 如果幸存者有特殊技能或道具可用，UI上显示其冷却或可用状态。例如携带医疗包可以在界面某处显示治疗图标及剩余次数。
    * **交互提示：** 当幸存者靠近可交互对象时，屏幕中央或下方出现提示文字，例如“按 F 键 修理发电机”或“按 F 键 拯救队友”。提示文字应清晰且随物件不同而变化，由代码在`Area2D`进入时设置。
    * **QTE界面：** 当触发技能检查QTE时，在幸存者HUD中央弹出QTE小窗口。设计QTE样式可参考《黎明杀机》：一个圆形转盘和一根指针不断旋转，当指针划过特定狭窄区域时，玩家需及时按键。由于2D界面实现可能简化，可以用一个进度条+标记的方式：例如一个条上游标快速移动，玩家需在游标到达标记区域时按键。UI上突出显示“按空格！”之类的字样。在QTE结束后，成功或失败结果以闪烁文字或颜色告知，比如成功显示“✔”绿勾，失败显示“✖”红叉和声音警报。QTE窗口持续很短时间后自动消失。
    * **其他：** 幸存者HUD还可包含基本**准星/指向**元素：例如在屏幕中心轻微标示准星用于指向互动对象。但大多2D情况下不需要精准准星。屏幕边缘可出现**指示标记**：例如队友受伤倒地时，在屏幕边缘朝向该队友位置给出一个箭头指示，颜色红色表示紧急情况。发电机、出口等重要物件也可在HUD上用图标标示方向（这可通过World->Screen转换物件位置成UI提示实现）。
  * **杀手HUD：**

    * **猎物计数：** 杀手界面顶部可显示剩余幸存者数量，例如“幸存者剩余：3人”，或者显示每个幸存者存活状态（类似幸存者的队友状态栏，但杀手可能不知道具体谁是谁，只需要知道有几个活着、几个已挂或死）。可以用简洁的图标表示：例如四个人形图标代表4幸存者，变灰表示已死亡，闪烁红色表示当前在钩子上等。这个信息方便杀手掌握大局。
    * **发电机进度提示：** 杀手需要了解幸存者目标完成情况。可以在HUD某处显示已修好的发电机数/总数（如同幸存者HUD的3/5），或者更有挑战性的是不直接给数字，让杀手根据现场信号判断（但为了游戏体验，可以给一个粗略指示）。我们建议还是显示明确的进度以减少挫败感：如顶部“发电机剩余：2”。
    * **能力冷却：** 若杀手有特殊能力（如瞬移、透视等），HUD上要有技能图标和冷却条/计时器显示，提示能力何时可用。如果没有特殊能力则无需此部分。
    * **交互提示：** 杀手交互项主要是拾起幸存者和挂钩。当杀手站在倒地幸存者旁时，出现提示“按 F 键 拖起幸存者”；扛着幸存者站在钩子前时，提示“按 F 键 挂上钩子”。另外如果设计杀手可以踹翻正在修理的发电机或破坏板子，也要有对应提示如“按 空格 破坏”。提示样式与幸存者类似。
    * **音效/视觉提醒UI：** 杀手HUD中一个重要元素是提示来自幸存者的**声响通知**。在《黎明杀机》中，幸存者触发的响动（如修理失败爆炸）会在杀手界面产生一个视觉提示（红色提示圈）并附带声音方向感。我们可以在2D中用一个屏幕边缘的动态图标表示声源方向和大致距离（远则小且透明，近则大且亮）。这种提示可以引导杀手行动。虽然算UI范畴，但实现可能结合游戏逻辑和音频系统。
    * **血迹和划痕：** 这些不属于HUD元素，而是游戏内效果（例如在地面绘制痕迹），但这里提及：为了给杀手反馈，可以将幸存者奔跑产生的踪迹当做游戏世界的UI（红色半透明纹理），杀手看到后追踪。此部分美术实现，在UI设计不详细展开，但开发中需要资源支持。
  * **通用元素：**

    * **计时器**（可选）：如果游戏设计有总体时间限制（例如每局最长10分钟），则在HUD顶端显示倒计时。倒计时归零则游戏结束判定杀手胜利（幸存者未逃出即算失败）。
    * **暂停菜单：** 在联机游戏中一般不允许暂停整个游戏，但单机开发时可以调试暂停。可以实现按ESC打开菜单，提供选项：音量调节、离开游戏（投降）等。联机进行中这个菜单只对本地有效，不暂停全局。
    * **结算界面：** 游戏结束后弹出。包括胜负结果（“幸存者胜利”或“杀手胜利”），各玩家得分统计（可以简单显示每个玩家完成的行动如修了几台机、击倒多少人等），返回主菜单或房间按钮。结算界面设计简洁，以列表呈现成绩。

* **QTE 系统 UI 细节：** QTE在幸存者HUD中以小型浮窗呈现，包含：

  * **进度圈或条：** 例如一个圆环代表时间进度，指针绕行一圈耗时1-2秒。目标区域用高亮标记一段弧。玩家需在指针进入高亮弧段时按下按键。实现上也可以用ProgressBar模拟一条进度，在特定区间着色，高速增加进度到100%时要求按键。圆形视觉可以更接近《黎明杀机》的风格。
  * **按键提示：** 告知玩家需要按哪一个键（PC端通常是空格或鼠标左键）。可以在圆圈中央绘一个空格键符号或相应手柄键图标。
  * **反馈：** 如果玩家及时按下，圆圈闪绿并伴随轻快音效，如果错过则闪红伴爆裂音效。提到失败会发出噪音吸引杀手注意——这个音效将通过音频系统播放给杀手听。
  * **多玩家情况：** 通常每次QTE只针对正在修理该发电机的某个幸存者触发。UI需支持不同玩家可能同时出现各自的QTE。例如两人修同一台发电机，可以每人单独判断自己的QTE成败。我们的实现简化为每次QTE事件由服务器指定一名玩家处理即可，避免多人同时QTE混乱。因此UI可以不用处理并发QTE。

* **UI 美术风格：** 统一采用像素美术风格的UI元素，按钮和图标尽量简洁。颜色搭配上，杀手相关元素用红色强调（危险、警告），幸存者相关元素用蓝色或绿色（表示进度、安全）。字体使用清晰可读的像素字体，重要提示加大字号或闪动效果突出。屏幕信息布置考虑电视和手机屏幕的安全区域，重要HUD不要靠边缘太近，以免被裁剪或手指遮挡。

* **布局适配：** 利用 Godot 的布局容器和锚点系统，使UI在不同分辨率和平台下都能良好显示。采用 **Anchor** + **Margin** 固定HUD的位置，例如发电机进度固定在顶部居中，队友状态固定在左侧中部等。移动设备屏幕较小，可考虑隐藏或缩小部分不关键的HUD元素（比如幸存者名字）以降低界面拥挤。使用 `Control` 节点的 `SizeFlags` 扩展/填充属性和 `Container` 容器（HBoxContainer, VBoxContainer, CenterContainer等）来自动调整布局。

* **输入交互：** 界面按钮支持键盘/手柄导航（获取焦点高亮，按确认键触发）。在PC上鼠标可直接点击。移动端则支持触摸点按。需要确保按钮足够大便于触摸。对于房间界面的玩家列表，可以不是交互控件，仅显示信息即可。

通过上述UI设计，玩家能方便地进行游戏的各项操作并实时获知游戏进程。UI模块与游戏逻辑通过信号通讯，例如发电机完成信号触发HUD更新，玩家状态变化触发HUD队友状态更新等。界面简洁直观且信息完整，在Cursor智能补全帮助下也能按照描述逐一实现各控件和布局。

## 7. 跨平台兼容与输入映射建议（含虚拟按键、触控支持）

本项目需兼容 Web、Android、iOS 平台，必须考虑不同平台的输入方式和性能特点。在设计和实现时遵循 **跨平台适配** 原则：

* **输入映射统一：** 利用 Godot 的 **InputMap** 系统定义抽象的动作，然后为不同设备绑定实际按键/触控。通过项目设置->输入映射添加以下主要动作：

  * 移动类：`move_up`, `move_down`, `move_left`, `move_right` 对应键盘的 W,S,A,D 或 方向键，上下左右；手柄的左摇杆/方向键；移动端则对应虚拟摇杆或方向区域。
  * 互动类：`interact` 对应键盘 F 键（或 E 键）; 手柄 X / □ 按钮; 触屏则为虚拟按钮。
  * 攻击类（仅杀手）：`attack` 对应键盘鼠标左键或空格; 手柄右触发; 触屏虚拟攻击按钮。
  * 奔跑切换：`sprint` 对应键盘 Left Shift; 手柄 B / ○; 触屏虚拟跑步按钮（或者双击摇杆区域实现）。
  * 技能类：如果有特殊技能，可定义 `ability1`, `ability2` 等，对应键盘数字键或手柄肩键; 触屏相应按钮。
  * 菜单类：`menu` 对应键盘 Esc; 手柄 Start/Options; 触屏可通过UI按钮实现菜单/暂停。

  在代码中使用 `Input.is_action_pressed("move_up")` 等来查询，从而**同一套逻辑**适配所有输入设备，不需要针对每平台写分支。**按键提示**在UI上可以根据当前平台自动切换图标或文本（Godot提供 `OS.get_name()` 或 `Input.get_connected_joypads()` 判断输入设备类型）。

* **桌面平台输入：** Web 与 PC 的输入类似，假定玩家使用键盘和鼠标（或手柄）。需要注意**Web端键盘输入**焦点问题：在嵌入网页时，要确保 canvas 获得焦点才接受按键。另外浏览器对某些按键有保留（如Esc可能退出全屏），可以引导玩家使用其他键。鼠标用于调整镜头在3D游戏很重要，但在2D俯视游戏中作用有限，可能仅用于UI点击，因此主要还是键盘操控角色。若支持手柄，需要做测试映射确保常见Xbox/PS手柄按键都正确绑定（Godot对XInput和SDL有默认映射，一般正常）。

* **移动平台输入：** 移动端没有实体键盘，采用**虚拟摇杆和按钮**来提供控制：

  * **虚拟摇杆：** 在屏幕左下角放置一个半透明圆形摇杆控件，用于角色移动。Godot没有内置专用摇杆节点，但可用 `TouchScreenButton` 或自定义脚本实现。可参考社区实现或Godot AssetLib中的 Virtual Joystick。简单方案：在左下区域放置一个大圆Area，当用户按下时记录起点作为中心，拖动时计算偏移向量归一化，映射为移动方向并调用对应的 InputAction（比如根据角度触发上下左右或直接用于Analog移动）。这样摇杆位置可以跟随初始触摸而动态定位。虚拟摇杆要有回弹视觉反馈，且半透明不遮挡太多视野。
  * **虚拟按钮：** 在屏幕右侧布置一些可点按的按钮：

    * 交互按钮：一个大按钮（如圆形图标“手”或“齿轮”）用于Interact动作。
    * 攻击按钮：杀手界面显示，一个带武器图标的按钮。
    * 奔跑按钮：一个“奔跑”小图标按钮，供幸存者按住或切换奔跑状态。如果实现Toggle，则按一下切换奔跑开/关，再按切回走路。
    * 技能按钮：若有特殊技能，也在右侧或上方放置对应图标按钮。
    * 这些按钮使用 `TouchScreenButton` 节点，可以直接设置关联 Input Action 名称。它们的 `visibility` 可根据角色类型或当前上下文进行切换（例如幸存者不显示攻击按钮，杀手不显示修理按钮等）。按钮美术要简洁清晰，按下时变化颜色或亮度以示反馈。
  * **相机控制**：2D游戏通常不需要手动镜头控制，但若需要拖动画面（如查看更大范围），可实现双指拖动移动摄像机或缩放。但初版可固定摄像机跟随角色，无需额外触控控制视角。
  * **触控适配UI：** 移动端UI需要防止手指遮挡游戏关键部分。将虚拟按键放在不影响主要视野的位置（左右下角）。HUD元素则稍上移避免和虚拟按键重叠。考虑不同屏幕比例，使用 Godot 的 `Container` 布局将虚拟按钮Anchor设定在屏幕边缘相对位置。

* **平台差异处理：** Godot 可以通过 `ProjectSettings.get_setting("application/run/platform")` 或检查 `OS.get_name()` 返回 "Android"/"iOS"/"HTML5" 来区分平台。在运行时可以据此调整一些逻辑。例如：

  * 在移动平台启动时，自动显示虚拟摇杆和按钮节点；在桌面平台则隐藏这些节点。
  * 在Web平台，可以禁用一些高性能特效或降低分辨率适配浏览器性能和内存限制；移动平台亦类似考虑降低粒子特效、关闭VSync等（像素游戏影响可能不大）。
  * Android需要在导出设置里启用 **INTERNET** 权限以允许联网；iOS则需要在Xcode项目中加入网络权限描述。Web平台由于走WebSocket，需要服务器支持SSL的WSS（若在HTTPS环境）等，这些部署相关事项超出文档范围，但需意识到。
  * 输入法冲突：移动端如果需要玩家输入文本（例如输入昵称），会弹出系统键盘遮挡界面，应将输入框顶上去或使用合理的GUI避免游戏区被挡。

* **屏幕适配与安全区域：** 特别在移动端，有不同的屏幕尺寸和刘海、水滴屏等。Godot有 `Viewport.get_safe_area()` 可获取安全显示区域，在放置HUD时可参考，确保不被刘海遮盖。可以在iOS上启用“use safe area”设置让engine自动调整CanvasLayer。我们的UI设计应留出边距。**横竖屏**方面，本游戏为横屏体验，在移动端需要锁定横屏（在导出设置中可指定），防止玩家中途旋转影响体验或布局。

* **性能考虑：** 移动设备性能和浏览器性能较PC低：

  * 像素游戏的美术量不大，但要小心**DrawCall**和**脚本效率**。优化TileMap绘制，合理使用Node，不要超出移动设备承受范围。可以在真机上测试帧率并剔除瓶颈。
  * 音频在移动端过多同时播放可能卡顿，尽量短小或用较低质量编码。Godot默认音频解码可能消耗CPU，重要音频可以预解码（在导出设置中）。
  * 网络上，移动网络延迟较大且不稳定，要允许一定的延迟裕量和丢包处理（高层API ENet已经有重发机制，但移动可能断开重连频繁，需要在设计上考虑允许重连或者直接判负退出）。
  * 输入上，由于触摸精度有限，不要求幸存者QTE精准和PC一样毫秒不差，可考虑移动端稍放宽QTE判定时间或扩大判定区域。

* **测试与调整：** 在开发过程中，需要在不同平台上测试UI布局和控制手感。特别是虚拟摇杆的灵敏度、半径需要调校，让玩家既能精细操作又不会动不动就触发奔跑。手柄也需要测试映射是否准确（Godot一般能处理主流手柄，无需特殊配置，但要提示玩家连接手柄后再启动游戏）。

总之，通过InputMap抽象和条件显示虚拟控件，我们可以做到“一套代码，多端适配”。使用Cursor AI编写代码时，也可以针对不同平台逻辑分别实现：如在一个输入初始化函数里，根据 `OS.get_name()` 生成/显示虚拟按键的节点层次，这样AI可以分别实现PC和移动的输入处理分支。确保交互体验在每个平台都流畅直观。

## 8. 美术资源接口与命名规范

美术资源包括图像、音频、字体等，需要良好组织和命名以方便引用和由AI协助整合。以下是资源管理和命名的规范：

* **资源目录结构：** 采用清晰的文件夹组织，美术资源和场景、脚本分开存放。建议的顶层目录：

  * `res://scenes/` 存放场景文件(.tscn)，可按功能再细分子目录，如 `scenes/characters/` (角色场景)，`scenes/objects/` (道具场景)，`scenes/ui/` (界面场景)等。
  * `res://scripts/` 存放GDScript脚本(.gd)，按模块划分子文件夹，对应第3节模块。如 `scripts/characters/Survivor.gd`, `scripts/objects/Generator.gd` 等。
  * `res://assets/` 存放美术资源，按照类型或用途细分：

    * `assets/sprites/` 或 `assets/textures/`：2D图像资源。可以进一步分：`characters` (角色相关sprite)、`objects` (道具物件图片)、`ui` (界面图标按钮)、`effects` (特效帧图)等。
    * `assets/tilesets/`: 地图TileSet资源（包含tile图片及场景配置）。
    * `assets/audio/`: 音频资源，分 `music` (背景音乐)、`sfx` (音效)，或者按场景分文件夹如 `audio/killer/`, `audio/survivor/`, `audio/environment/` 等。
    * `assets/fonts/`: 字体文件(如像素字体.ttf)。
    * 如果有动画序列帧图，也可放在sprites子目录中以名称区分。
  * `res://animations/`: 可选，用于存 `.ani` 或 `.tres` 动画资源，比如 `SpriteFrames` 资源文件。

  这种结构便于在Godot的FileSystem中快速找到所需资源。也利于AI搜索资源名，一致的目录便于批量加载。

* **文件命名规范：** 统一使用 **snake\_case（全小写加下划线）** 来命名文件和资源。避免空格和特殊字符。尽量做到见名知意。

  * 纹理(image)文件：可以以对象名开头，如 `survivor_idle.png` (幸存者待机动画精灵表)，`survivor_run.png`, `killer_attack.png`, `generator.png` (发电机静态图或Sprite表)等。若动画帧过多，也可按序号分成多文件夹，但Godot更倾向于将动画做成SpriteFrames资源，所以可以把序列帧拼成一个整图+SpriteFrames剪切。
  * TileSet图集：如 `tiles_outdoor.png`, `tiles_building.png` 等，对应不同环境。
  * UI元素：如 `icon_generator.png` (发电机图标), `btn_interact.png` (交互按钮图标), `bg_main_menu.png` (主菜单背景)等。
  * 音频：以用途命名，例如 `bgm_menu.ogg` (主菜单背景音乐), `sfx_heartbeat.wav` (杀手心跳声), `sfx_generator_fix.wav` (修理时机械声), `sfx_generator_explode.wav` (QTE失败爆炸声), `sfx_killer_attack.wav`, `sfx_survivor_hurt.wav` 等。可以按角色或场景前缀区分，方便管理音效类别。
  * 脚本和场景命名：Godot 4推荐场景和脚本文件用 snake\_case, 但节点名使用 PascalCase。例如场景文件 `survivor.tscn`，其根节点可以命名为 "Survivor". 脚本 `Survivor.gd` (这里类名大写S) 绑定此节点。为避免混淆，可以采用类名PascalCase、文件名snake\_case的形式，Godot允许脚本内用 `class_name Survivor` 注册类名。\*\*注意：\*\*最好保持脚本类名和文件名含义对应，AI生成代码时也能推断正确文件。

* **节点命名约定：** 在场景中给重要节点命清晰名称，遵循 PascalCase 风格以与Godot内置节点风格一致。如角色场景中，Sprite节点命名为 "Sprite" 或具体 "CharacterSprite", 碰撞体 "Collision", 子节点如 "HitArea", "AnimationPlayer" 等。统一命名有助于通过代码 `get_node("Sprite")` 访问，降低AI或程序员弄错概率。对于多个同类节点的容器，用复数命名且首字母大写，如之前示例的 "Generators", "Players" 容器节点。

* **资源加载与引用：** 在代码中对于资源的获取，可以使用预加载或加载：

  * 关键资源如场景预制，可以在脚本头使用 `@onready var GeneratorScene = preload("res://scenes/objects/generator.tscn")` 提前加载。这样AI在实现spawn逻辑时可直接使用该变量实例化，提高代码清晰度。预加载对于音效和纹理也适用，如 `preload("res://assets/audio/sfx_explode.wav")`。但注意不要一次预载太多大资源占用内存，某些可以按需加载。
  * 可采用 `ResourceLoader.load()` 或 `load()` 动态加载资源路径。如果采用路径字符串，必须与命名规范匹配才能加载正确文件。所以保持良好命名可以减少错误。
  * 在UI设计中，将图形元素拖入TextureRect或Button的Icon属性，可以直接在编辑器配置。如果通过代码动态赋值图标，则按命名规则引用对应文件即可。
  * **命名一致性对AI的帮助：** 在使用 Cursor AI 生成代码时，如果文档清楚指明了资源名称和路径，AI可以更准确地插入这些名称。例如，如果在第3节模块设计已说明有 `res://scenes/objects/generator.tscn`，后续叫AI编写生成发电机的代码时，可提示使用该路径的场景，使生成结果更准确可用。

* **艺术风格与接口：** Pixel风格意味着美术资源通常低分辨率(例如每角色高度32px或64px等)。在Godot中，为避免像素模糊，需在导入设置中关闭纹理的过滤(Filter)属性，启用 Pixel Snap（像素对齐）选项。可以全局设置默认Importer对 `.png` 关闭过滤。此外，为兼顾不同分辨率，可能需要提供@2x资源等，但2D像素游戏一般采用一种分辨率统一缩放。UI元素如果是像素画，也应遵循此规则。

  * 如果美术以逐帧图提供，需要整理成 `SpriteFrames` 资源：Godot编辑器中创建 `SpriteFrames`，把帧图按正确顺序加入，并命名Animation。如 `survivor.frames` 里面 Idle动画5帧、Run动画6帧等。然后在角色场景的 AnimatedSprite2D 指定该SpriteFrames资源。通过这种方式，代码里只需调用动画名。AI编写代码时也可假定动画已在编辑器配置完毕，无需逐帧添加，以节省精力。
  * 对音频，为了实现分层控制，需将不同类别音频分配到对应**音频总线 (Audio Bus)**。可在Godot的Audio面板设置例如 `Master` 下创建 `SFX`, `Music`, `Ambient` 子总线。然后在播放音效时指定 `AudioStreamPlayer.bus = "SFX"` 等。资源命名上已经区分了sfx和bgm，可以据此选择bus。AI在生成音频播放代码时，也可以根据文件名前缀决定音量和bus设置（例如凡是sfx\_开头的音频，播放时用SFX总线）。

* **资源命名示例：** 以下给出一些具体名称示例：

  * Sprites: `killer_sprite_sheet.png`（杀手动画拼图），`survivor_walk_strip.png`（幸存者行走动画横向拼合图），`hook.png`（钩子静态图），`pallet_sheet.png`（木板翻倒动画）。
  * UI: `icon_survivor_health.png`（幸存者状态图标），`icon_survivor_injured.png`，`icon_hook.png`，`bg_lobby.png`（房间背景），`btn_start.png`，`btn_ready.png` 等。
  * Audio: `sfx_heartbeat.wav`（心跳音），`sfx_generator_complete.wav`（发电机完成声），`sfx_hatch_open.wav`（地道出现声，如果有），`music_lobby.ogg`（大厅音乐），`music_game_intense.ogg`（对局紧张背景音乐，如果需要可以淡淡的环境音替代音乐）。

* **版本管理与协作：** 虽然与题无关，但在实践中建议使用Git等版本管理跟踪资源变动。文件命名清晰也便于代码合并。AI辅助生成代码时，如有资源名称变化，需及时更新文档和再次提示AI使用新名称。

通过遵循以上命名规范和目录组织，可以极大降低人工和AI查找资源的时间，减少引用错误。美术资源与代码解耦良好，插画、美术师可直接往assets目录添加内容而不影响代码，只要按照命名规则。AI 在需要时也可根据资源命名自动推断用途，如看到`survivor_idle.png`就能知道这是幸存者待机动画资源。在与 Cursor 的交互中，这些明确的资源接口定义能使AI迅速正确地写出加载和使用资源的代码。

## 9. 音频系统分层（环境音、角色音、QTE提示）

音频在营造游戏氛围和提供反馈方面至关重要。本项目音频系统将采用分层管理的方法，将不同类型的声音分配到不同的音频通道（Audio Buses）和由不同节点控制，以便调节音量和触发时机。设计原则是**环境音效衬托氛围，角色音效提供反馈，QTE提示强化交互**：

* **音频通道划分：** 在Godot的Audio Bus布局中，设置如下通道：

  * **Master：** 主通道，所有声音最终汇聚于此。可整体控制游戏总音量。
  * **Music：** 用于背景音乐或环境背景音的通道。将音乐类资源（如主菜单音乐，对局氛围背景声）输出到Music，总音量可独立调节。
  * **SFX：** 用于一般音效的通道，包括角色动作音效、UI提示音效等。大部分短音频都归入此类，比如脚步声、攻击声、UI点击声。
  * **Ambient：** （可选）用于环境环境音效，如风声、虫鸣、远处的低语等长期循环音效。如果背景音较复杂，可区分Ambient与Music，把Ambient用于循环环境声而Music用于音乐（比如开始或结算时的音乐）。
  * **Voice：** （可选）用于角色“人声”类的音频，比如幸存者受伤的呻吟、尖叫，杀手的笑声、咆哮等。如果将其和其他SFX分开，可以让玩家单独调整人物声音大小。
  * **UI：** （可选）用于UI界面音效，如准备提示音，QTE开始/成功/失败提示音。这也可归入SFX，但如果玩家想单独调低UI声音，可以拆出。

  分层的好处是玩家可在设置中调整各类声音音量，比如静音音乐但保留音效等。实现上，在Godot **AudioBusLayout** 中添加上述总线，合理排列（Music和Ambient可并列挂Master，SFX、Voice、UI并列挂Master或甚至SFX下再细分UI等，看需求）。

* **环境音 (Ambient/Music)：** 用于营造地图氛围的循环音。根据关卡不同，可以有不同的环境底噪：

  * 例如森林地图背景可以播放**夜晚虫鸣**和**风吹树叶**声；医院地图播放**电流噪声**和**低沉风声**等。可将多个环境声混合降低音量播放，使玩家身临其境但不干扰游戏声音。
  * 背景音乐方面，《黎明杀机》在游戏对局过程中主要以环境声为主，没有明显的音乐旋律，只有在追逐时才有紧张音乐。因此本项目可采取类似做法：**平时无音乐，仅环境音**；**当杀手进入追逐状态**时，在杀手和被追幸存者客户端触发紧张音乐段落。例如快速的心跳加弦乐，用于提升紧迫感。这段音乐可以持续直到追逐结束（杀手失去目标或幸存者倒下）。
  * 主菜单和结算界面可以有主题音乐，用以提升游戏辨识度。比如主菜单播放一段主题旋律（循环1分钟左右），结算界面播放胜利或失败的音乐段（分别不同氛围）。
  * 音频资源上，背景循环音使用AudioStreamPlayer在Autoload或游戏场景中播放，一局游戏中循环播放。追逐音乐可以额外一个AudioStreamPlayer，当需要时淡入淡出切换。Godot AudioStreamPlayer 支持调整 `volume_db` 和 `pitch_scale`，可以用来比如当杀手接近幸存者时心跳声音量增加、频率加快，这里也算环境音的一部分模拟心跳。

* **角色音效 (SFX/Voice)：** 角色的动作和状态声音提供直接反馈：

  * **幸存者声音：** 包括受伤时的**呻吟/喘息**（循环或者定期播放，表示疼痛状态），倒地时的**痛苦喊叫**，被攻击到的一瞬**惨叫**，被挂上钩子的**尖叫**，以及在钩子上挣扎时的喘气和哀嚎。这些声音由幸存者客户端或所有客户端播放？理想情况应由所有在附近的玩家都能听到。所以**声音范围**很重要：Godot 2D 可以使用 `AudioStreamPlayer2D` 并设置 `attenuation` 属性，根据距离衰减音量。做法是将AudioStreamPlayer2D附在角色节点上，这样声音有位置。在播放如惨叫声时，所有客户端都会触发播放，但只有距离近的玩家能明显听见（这由AudioServer计算衰减，不需要我们手动判断）。

    * 受伤呻吟可以每隔几秒由幸存者角色自己播放AudioStreamPlayer2D（循环属性可以开，但是需要同步开始时间或本地各自播放无妨）。
    * 尖叫惨叫这些一次性，通过RPC广播由各客户端在对应角色节点播放对应声音资源。
  * **杀手声音：** 杀手的**脚步**往往沉重可被幸存者微弱听见（可实现为在杀手移动时播放低音脚步，在一定半径内幸存者客户端播放）。杀手攻击挥动武器有**挥砍音**，命中有**命中音效**（可能是武器砍入肉体的声音，和幸存者的痛叫双重叠加）。杀手如果有特殊能力，比如传送，使用时附带**能力音效**。一些氛围声音如**杀手视角下的心跳音**（DBD中幸存者靠近杀手听到自己心跳，但我们也可在杀手端或全局播放心跳增强气氛）。

    * 杀手的笑或怒吼可以在开局或胜利时播放加强角色形象。
  * **互动物件声音：** 这些也算SFX类：发电机修理时有**机械嘎吱声**（loop，在有人修理时播放，该AudioStreamPlayer2D放在发电机位置，让附近的人都听到运转声），修理完有**发电机启动音**(叮一声亮灯)，失败爆炸有**电花爆裂声**。板子被推倒有**木板撞击声**，柜子躲藏有**开关柜门声**。出口门开启拉闸有**重型门闸声**。这些音效在设计上每个物件脚本里会触发，可由物件的AudioStreamPlayer2D来播放，以便定位声音来源真实。

* **QTE提示音:** QTE相关的音效层次：

  * 当QTE环出现时，可以播放一个**开始提示音**（小音效“ding”），提示玩家注意力。
  * QTE计时过程中可能伴随**节拍音**（比如指针每经过一段都有节奏滴答声），视需要决定简化与否。可以只在快到目标区域时心跳加速音效提高音量提醒。
  * 成功按键时播放**成功音效**（轻快的短音，如叮咚），失败时播放**失败音效**（刺耳的错误音，如电流短路声）。失败音效应该够响亮以被附近杀手听见作为线索。
  * 这些QTE UI音效可使用独立的AudioStreamPlayer（2D或UI）。由于QTE对其他玩家的反馈主要是失败音（爆炸声）影响杀手，所以失败声应该是Generator对象上的音频，在所有端播放。而成功QTE往往没有全局声音，仅在玩家本地轻音提示即可。
  * 为不混淆音频管理，UI层面的按键提示音可以路由到UI或SFX总线均可。如果细分UI Bus，可以把成功/失败提示放UI bus，这样玩家可以调低UI声音不影响环境音。

* **音频播放实现**:

  * 在Godot中，为每个持续存在的角色和重要物件各挂载AudioStreamPlayer2D节点（或需要多个不同声音就多个节点或动态切换音频流）。例如角色节点下：`Audio_Player_Voice`（用于惨叫、呻吟），`Audio_Player_Footstep`，物件如发电机节点下 `Audio_Loop`（修理声），`Audio_OneShot`（爆炸声）等。
  * 对于一些需要集中管理的UI和音乐声音，可以设置一个全局的 AudioManager 节点（可能作为Autoload或场景子节点）。AudioManager可包含一个AudioStreamPlayer用于背景音乐，和用于UI音效的AudioStreamPlayer（非2D，因为UI音效无位置）。
  * 音效触发：由相应事件的代码调用。例如在幸存者 `take_damage()` 函数里，若health\_state从健康变为受伤，则`Audio_Player_Voice.stream = hurt_sound; Audio_Player_Voice.play()`，从受伤变倒地则播放`downed_sound`等等。这些调用可以让AI根据文档中列出的sound名称放入正确资源（如果资源路径命名清晰如 sfx\_survivor\_hurt）。
  * 音量控制：Godot允许代码控制bus音量，如 `AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Music"), -10)` 降低音乐10dB。游戏内可提供设置UI连接这些接口。Cursor AI编写设置菜单代码时，可参考这个调整各Bus音量的调用。

* **多平台注意：** Web端音频通常只能在用户交互后开始播放（浏览器限制自动播放），要确保游戏有点击后才启动声音。移动端可能性能问题，尽量用 `.ogg` 或 `.wav` 小文件，避免过长的音频延迟加载（可在加载界面提前加载）。音频Channels不宜过多以免增加CPU混音负担，但Godot音频引擎一般能支持几十声道问题不大。

* **音效资源列举：** 为方便AI对接，提供主要音效资源名清单：

  * 环境：`ambient_forest_night.ogg`, `ambient_wind.ogg`, `ambient_factory_hum.ogg`
  * 音乐：`music_menu.ogg`, `music_chase.ogg`, `music_win.ogg`, `music_lose.ogg`
  * 幸存者：`voice_survivor_hurt.wav`, `voice_survivor_down.wav`, `voice_survivor_moan.wav` (受伤呻吟循环), `voice_survivor_scream.wav` (上钩惨叫)
  * 杀手：`sfx_footstep_killer.wav` (杀手脚步，可多帧不同声组合)，`voice_killer_attack.wav` (攻击吼声)，`voice_killer_laugh.wav` (胜利笑)
  * 物件：`sfx_generator_run.wav` (运转声), `sfx_generator_explode.wav`, `sfx_generator_complete.wav`, `sfx_pallet_drop.wav`, `sfx_exitgate_open.wav`
  * QTE/UI：`sfx_qte_start.wav` (开始提示), `sfx_qte_success.wav`, `sfx_qte_fail.wav`, `sfx_menu_click.wav`, `sfx_menu_back.wav`

将声音合理整合进游戏能提升沉浸感：玩家通过环境音感受地图氛围，通过声音提示（心跳、惨叫、爆炸）获取游戏信息，通过音乐和效果声被情绪感染。音频系统的分层设计保证这些声音各司其职又不相互淹没，玩家可以根据喜好调整。开发中可以先整合关键声音（比如发电机、攻击和惨叫），逐步丰富其它音效。在Cursor帮助下，可以先让AI实现一个声音播放管理器，根据事件触发函数调用对应播放函数，再逐步插入具体音效资源。

## 10. AI 提示工程指引：如何与 Cursor 高效协作（指令范式、提示结构、代码片段生成建议）

为充分利用 Cursor 等 AI 编程助手提高开发效率，本节提供一些**提示工程 (Prompt Engineering)** 的技巧和范式，指导如何与 AI 高效协作完成本项目各模块。通过正确撰写指令、结构化上下文和请求代码片段，能让 AI 更准确地理解需求，生成高质量的 GDScript 代码。

* **整体策略：** **逐步分解任务，模块化实现**。结合第3节的模块划分，不要一次性让AI生成整个游戏的所有代码，而是按模块或功能逐个请求。这样既减小每次问题规模，也方便测试和集成。每个模块可再细分功能点，与AI交互呈循环迭代：**描述需求 → AI 产出代码 → 手工检查测试 → 根据结果再细化提示完善**。

* **提供上下文：** Cursor 支持将多个文件和内容提供给AI参考。应充分利用这一点：

  * 在让AI编写某模块代码前，先将相关的设计文档片段提供上下文。比如想让AI实现 `Survivor.gd`，可先复制本设计文档第5节中关于幸存者状态和交互的部分给AI，让AI理解角色逻辑。
  * 如果已有一些约定或依赖（如某全局变量名，已实现的Base类函数），也在提示里说明或附上代码。上下文越清晰，AI 越能保证新代码与现有代码衔接良好。
  * 利用 Cursor 的多文件能力，可以打开 `Character.gd`（若已存在部分实现）和 `Survivor.gd` 空文件，让AI参考Character基类接口在Survivor中override实现。提示可以是：“根据设计文档和Character.gd中定义的接口，实现Survivor.gd，重点包括修理交互和状态切换。”

* **明确指令范式：** 编写提示时语言要精确简洁。可以使用以下模式：

  1. **功能描述**：先用一两句话说明要实现的功能模块。例如：“Implement the Survivor character class for the multiplayer horror game.”
  2. **细节要求**：列出具体要求点，最好用要点列举方式。可参考设计文档内容摘要。例如：

     * "State machine with states: Idle, Repairing, Helping, Running, Injured, Downed, Carried, Hooked, Escaping."
     * "Methods to start/stop repairing a Generator, with RPC calls to notify server."
     * "Integrate with Character base class (inherits Character.gd)."
     * "Play corresponding animation on state change (AnimatedSprite2D)."
     * "Signal when repair is completed or when hooked (for HUD update)."
  3. **上下文信息**：如果需调用或与其他类互动，在提示中告知已有的接口或变量。如：“The Character.gd base class has properties `health_state` and `state`, and a method `die()` to handle death. Use those instead of duplicating.” 或 “There is a global GameLogic singleton to call when a generator is completed: `GameLogic.generator_fixed()`.”
  4. **输出格式**：要求AI直接给出代码。有时可以指示：“Provide only the GDScript code for Survivor.gd script, without additional explanation.” 这样Cursor会专注代码输出。如果需要解释，可以不要求这一条。

  例如，一个具体的提示可以是：

  ```
  根据以下设计文档内容，实现 GDScript 脚本 Survivor.gd，继承 Character.gd 基类。需求：
  - 实现幸存者状态机（Idle, Repairing, Helping, Running, Injured, Downed, Carried, Hooked 等），使用枚举或字符串表示当前状态，并在不同事件切换状态。
  - 与 Generator 对象交互：当调用 start_repair(generator) 时进入 Repairing 状态，调用 stop_repair 时退出。
  - 使用 RPC 将修理行为通知服务器，并处理服务器指令的 QTE 成功/失败结果（如收到 server 通知失败则中断修理状态）。
  - 处理被攻击：提供 on_hit(attacker) 方法，被调用时如果健康则切换 Injured，如果已受伤则切换 Downed 并 rpc 通知服务器倒地。
  - 实现被扛起 (Carried) 和被挂 (Hooked) 状态的标记，以及对应的逃脱尝试（可加入 wiggle 计时逻辑占位）。
  - 每个状态切换时，播放 AnimatedSprite2D 对应的动画，触发相应的音效（调用 Character.gd 提供的play_sound接口）。
  请给出完整的 Survivor.gd 脚本代码：
  ```

  这样的提示结合中英文，加上关键点，Cursor 基本可以产出符合要求的脚本框架。

* **控制生成节奏：** 如果AI输出太长不易检查，可要求拆分。例如“先实现基本状态切换和RPC，不包括音效和动画，稍后再补充。” 这样先拿到核心逻辑，再逐步让AI补充。Cursor可以在生成后继续根据新指令修改或添加代码，所以可以先生成一个版本，然后对AI说“在上面的代码基础上，加上在修理进度中的 QTE 处理逻辑”之类的。

* **验证与调试：** 让AI帮忙不只是生成代码，还可以用于调试：

  * 如果运行时出现报错或逻辑不对，可以将错误信息或异常现象复制给AI，请它分析。例如：“When I run, I get error 'Invalid get index "health\_state" on Nil'. What could be the issue?” AI也许会指出可能某对象未初始化或拼写错误，让你迅速定位问题。
  * 可以请 AI 检查代码风格或优化：“Review the following code for any mistakes or improvements.” 递给它你的脚本，它会指出可能的问题，比如忘记某个RPC注解，或者逻辑漏洞。
  * 由于AI对Godot引擎API了解可能不全面，必要时可以把Godot文档片段提供让AI参考正确用法。例如Projectile同步、Navigation等冷门API。

* **代码片段生成：** 针对一些重复或模板化的代码，可以直接让AI批量生成:

  * 例如**InputMap配置**：提供要映射的动作列表，让AI给出在 `_ready()` 中用 `Input.map_action` 添加的代码块，或者 `.input_actions` 文件格式。如果不熟悉可以要求它给ProjectSettings写法。
  * **信号定义和连接**：比如想让AI为发电机实现一个 `completed` 信号，并在GameLogic中连接，可让AI写出connect代码。
  * **RPC函数**：Godot4 RPC注解比较新，可以例示一两个然后让AI为剩下函数加上适当注解和 `rpc_id` 调用。

* **提示示例总结：** 以下是几个与Cursor协作的示例场景：

  1. **实现模块**：*“请根据设计文档第3部分的模块说明，实现 GameLogic.gd 脚本，负责接收发电机完成信号和玩家逃生/死亡事件，判断游戏结束条件并通过RPC通知所有客户端游戏结束和胜者。代码需要定义信号 game\_over(winner) 并在条件达成时发射。”*
  2. **修改代码**：*“在 Survivor.gd 中添加功能：当幸存者进入 Hooked 状态时，启动一个 Timer 计时，例如第一次挂计时60秒，超时则触发死亡。请在现有 Survivor.gd 代码基础上加入此逻辑。”*  ——  Cursor会基于上下文插入 Timer 节点和超时处理。
  3. **生成资源加载**：*“项目中有若干音效文件列在文档第9节。请编写 AudioManager.gd 脚本，将这些音效通过 preload 预加载为成员变量，并提供方法 play\_sound(name) 可以播放对应音效到合适的Bus。例如调用 play\_sound('generator\_explode') 时在 SFX 通道播放 sfx\_generator\_explode.wav。代码里定义一个字典 sound\_map 映射名称到 AudioStream。”*
  4. **调整Bug**：*“在前述 Survivor.gd 实现中，如果幸存者在Repairing状态被攻击，状态应该转为Downed但目前代码没有处理这一情况，请补充相应逻辑（中断修理并改变状态）。”*  ——  AI会定位相关位置加代码。

* **与Cursor沟通注意：**

  * 如果AI对需求理解错误，可尝试重述或提供更明确示例。比如AI漏掉RPC注解，就显式告诉它“Please add @rpc annotation to network methods, e.g. use @rpc("any\_peer", "call\_local") for client input methods.”
  * 控制AI生成的长度，Cursor界面尽量分片查看代码，必要时让它分段输出多个文件，不要把所有脚本糅在一起输出导致混乱。
  * 保持**一致的术语**：文档里怎么叫，提示里就用那个词，避免AI困惑。例如我们用“发电机 Generator”、“幸存者 Survivor”，就在提示中使用相同英文类名，别用别的代称，这样AI上下文一致性更好。

* **AI辅助范围**： 除了代码编写，AI还能辅助**写文档注释**、**生成测试用例**。可以在主要函数让AI自动添加注释解释参数和作用。也可让AI写一些调试用的输出，比如“Write a debug print in on\_hit to log health\_state changes”来协助测试。

通过以上方法，与 Cursor 的协作将更高效顺畅。**撰写清晰的指令**和**提供充分的上下文**是关键：Cursor虽强大，但只有理解了我们的真实意图才能给出期望的结果。本设计文档本身就是AI的重要参考，在与Cursor对话时，不妨多引用本档内容让AI知悉我们的设计决策，从而编写出的代码更贴合需求。一旦AI生成的代码通过测试，我们即可整合进入项目，不断迭代完善，最终高效地完成整个游戏开发。
